<!-- omit in toc -->
# Подробное описание системы частиц с плоскостным аттрактором

<!-- omit in toc -->
## Содержание

- [Общая структура приложения](#общая-структура-приложения)
  - [Архитектура](#архитектура)
  - [Ключевые компоненты](#ключевые-компоненты)
- [Система частиц](#система-частиц)
  - [Жизненный цикл частицы](#жизненный-цикл-частицы)
  - [Параметры частиц](#параметры-частиц)
  - [Эмиттер](#эмиттер)
  - [Следы частиц](#следы-частиц)
- [Аттрактор](#аттрактор)
  - [Математическая модель](#математическая-модель)
  - [Расчет силы притяжения](#расчет-силы-притяжения)
  - [Визуализация аттрактора](#визуализация-аттрактора)
- [Физика движения](#физика-движения)
  - [Алгоритм обновления позиций](#алгоритм-обновления-позиций)
  - [Влияние аттрактора](#влияние-аттрактора)
- [Рендеринг и визуализация](#рендеринг-и-визуализация)
  - [Отрисовка частиц](#отрисовка-частиц)
  - [Отрисовка следов](#отрисовка-следов)
  - [Прозрачность](#прозрачность)
- [Камера и управление](#камера-и-управление)
  - [Орбитальная камера](#орбитальная-камера)
  - [Управление мышью](#управление-мышью)
- [Интерфейс пользователя](#интерфейс-пользователя)
  - [Информационные панели](#информационные-панели)
  - [Клавиатурное управление](#клавиатурное-управление)
- [Оптимизации](#оптимизации)
  - [Управление ресурсами](#управление-ресурсами)

## Общая структура приложения

### Архитектура

Приложение построено на основе модульной архитектуры, где каждый компонент отвечает за определенную функциональность. Взаимодействие между компонентами происходит через четко определенные интерфейсы, что обеспечивает слабую связанность и возможность легкой модификации отдельных частей.

- `main.py` - точка входа в приложение
- `particle_system.py` - система частиц и логика их движения
- `plane_attractor.py` - реализация плоскостного аттрактора
- `camera.py` - управление камерой и проекцией

### Ключевые компоненты

- **ParticleSimulation** - основной класс, управляющий симуляцией
- **ParticleSystem** - реализует систему частиц с цилиндрическим эмиттером
- **Particle** - отдельная частица с индивидуальными свойствами
- **PlaneAttractor** - плоский аттрактор, влияющий на движение частиц
- **Camera** - орбитальная камера с управлением мышью

## Система частиц

### Жизненный цикл частицы

1. **Создание**: частица генерируется на поверхности цилиндрического эмиттера с случайными параметрами
2. **Движение**: частица перемещается под влиянием начальной скорости и аттрактора
3. **Старение**: с течением времени уменьшается время жизни и прозрачность частицы
4. **Исчезновение**: по истечении времени жизни частица удаляется и создается новая

```python
def update(self, dt, attractor=None):
    # Применение силы аттрактора
    if attractor:
        attraction_force = attractor.get_force(self.position)
        self.velocity = self.velocity + attraction_force * dt

    # Обновление позиции
    self.position = self.position + self.velocity * dt

    # Добавление точки в след
    self.trail.append(self.position.copy())

    # Старение частицы
    self.lifetime -= dt

    # Обновление прозрачности
    life_ratio = self.lifetime / self.max_lifetime
    self.color[3] = life_ratio

    # Проверка на окончание жизни
    return self.lifetime > 0
```

### Параметры частиц

Каждая частица характеризуется следующими параметрами:

- **position** - трехмерный вектор положения
- **velocity** - трехмерный вектор скорости
- **size** - размер (радиус) частицы
- **color** - цвет с альфа-каналом для прозрачности
- **lifetime** - оставшееся время жизни
- **max_lifetime** - максимальное время жизни
- **trail** - история позиций для отображения следа

### Эмиттер

Цилиндрический эмиттер генерирует частицы со своей поверхности:

```python
def create_particle(self):
    # Случайный угол вокруг цилиндра
    angle = random.uniform(0, 2 * math.pi)

    # Случайная высота вдоль цилиндра
    height = random.uniform(-self.emitter_height / 2, self.emitter_height / 2)

    # Позиция на поверхности цилиндра
    x = self.emitter_radius * math.cos(angle)
    y = height
    z = self.emitter_radius * math.sin(angle)
    position = np.array([x, y, z])

    # Нормаль к поверхности цилиндра (направлена наружу)
    normal = np.array([math.cos(angle), 0, math.sin(angle)])

    # Скорость в направлении нормали
    speed = random.uniform(self.min_speed, self.max_speed)
    velocity = normal * speed

    # ... генерация других параметров ...
```

### Следы частиц

Каждая частица оставляет за собой след - набор последних позиций, через которые она прошла:

```python
# След хранится как список предыдущих позиций
self.trail = [position.copy()]

# При обновлении позиции добавляется новая точка
self.trail.append(self.position.copy())

# При достижении максимальной длины следа, старые точки удаляются
if len(self.trail) > max_length:
    self.trail = self.trail[-max_length:]
```

## Аттрактор

### Математическая модель

Плоский аттрактор определяется уравнением плоскости:

`Ax + By + Cz + D = 0`, где:

- `(A, B, C)` - нормаль к плоскости,
- `D` - свободный член, рассчитываемый из положения плоскости.

### Расчет силы притяжения

Сила притяжения зависит от расстояния до плоскости и задается формулой:

```python
def get_force(self, position):
    # Расчет знакового расстояния от точки до плоскости
    point = np.array(position)
    distance = self.A * point[0] + self.B * point[1] + self.C * point[2] + self.D

    # Если расстояние больше радиуса действия, сила не применяется
    if abs(distance) > self.range:
        return np.zeros(3)

    # Сила тем сильнее, чем ближе частица к плоскости
    force_magnitude = self.strength * (1.0 - abs(distance) / self.range)

    # Направление силы - к плоскости
    force_direction = -np.sign(distance) * self.normal

    return force_magnitude * force_direction
```

### Визуализация аттрактора

Аттрактор отображается как полупрозрачная плоскость со стрелкой-нормалью:

1. Создаются два перпендикулярных вектора на плоскости
2. На их основе строится видимый четырехугольник
3. Нормаль отображается как линия от центра плоскости

```python
def draw(self):
    # ... создание векторов для визуализации ...

    # Рисуем полупрозрачную плоскость как четырехугольник
    gl.glEnable(gl.GL_BLEND)
    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)

    gl.glBegin(gl.GL_QUADS)
    gl.glNormal3f(*self.normal)
    for corner in corners:
        gl.glVertex3f(*corner)
    gl.glEnd()

    # Рисуем нормаль как стрелку
    gl.glDisable(gl.GL_LIGHTING)
    gl.glColor3f(1, 1, 0)  # Желтый цвет
    gl.glBegin(gl.GL_LINES)
    gl.glVertex3f(*self.position)
    gl.glVertex3f(*(self.position + self.normal * 2))
    gl.glEnd()
    gl.glEnable(gl.GL_LIGHTING)
```

## Физика движения

### Алгоритм обновления позиций

Для каждой частицы на каждом шаге симуляции:

1. Вычисляется сила, действующая на частицу от аттрактора
2. Сила преобразуется в изменение скорости частицы
3. Новая скорость используется для обновления позиции

`Velocity = Velocity + (AttractorForce * dt)`

`Position = Position + (Velocity * dt)`

### Влияние аттрактора

- Аттрактор влияет на частицы только в определенном радиусе действия
- Сила притяжения тем больше, чем ближе частица к плоскости
- Направление силы всегда перпендикулярно к плоскости

## Рендеринг и визуализация

### Отрисовка частиц

Частицы отображаются как точки с настраиваемым размером, используя режим непосредственной отрисовки OpenGL:

```python
gl.glEnable(gl.GL_POINT_SMOOTH)
gl.glPointSize(8.0)
gl.glBegin(gl.GL_POINTS)
for particle in self.particles:
    gl.glColor4f(*particle.color)
    gl.glVertex3f(*particle.position)
gl.glEnd()
```

Использование `GL_POINT_SMOOTH` обеспечивает сглаживание точек для лучшего визуального представления.

### Отрисовка следов

Следы отображаются как линии, соединяющие предыдущие позиции частицы, также с использованием режима непосредственной отрисовки:

```python
gl.glBegin(gl.GL_LINES)
for particle in self.particles:
    if len(particle.trail) > 1:
        trail_alpha_step = particle.color[3] / len(particle.trail)

        for i in range(len(particle.trail) - 1):
            alpha = particle.color[3] - (i * trail_alpha_step)
            gl.glColor4f(particle.color[0], particle.color[1], particle.color[2], alpha)
            gl.glVertex3f(*particle.trail[i])
            gl.glVertex3f(*particle.trail[i + 1])
gl.glEnd()
```

### Прозрачность

Прозрачность частиц зависит от их оставшегося времени жизни:

```python
# Отношение оставшегося времени к максимальному
life_ratio = self.lifetime / self.max_lifetime

# Применение к альфа-каналу цвета
self.color[3] = life_ratio
```

Для корректной работы прозрачности используется альфа-смешивание:

```python
gl.glEnable(gl.GL_BLEND)
gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
```

## Камера и управление

### Орбитальная камера

Реализована орбитальная камера, которая вращается вокруг центра сцены:

```python
def apply(self):
    # Преобразование сферических координат в декартовы
    theta_rad = math.radians(self.theta)
    phi_rad = math.radians(self.phi)

    x = self.distance * math.sin(theta_rad) * math.cos(phi_rad)
    y = self.distance * math.sin(phi_rad)
    z = self.distance * math.cos(theta_rad) * math.cos(phi_rad)

    # Установка позиции и ориентации камеры
    glu.gluLookAt(
        x, y, z,       # Позиция камеры
        *self.target,  # Центр, на который смотрит камера
        0.0, 1.0, 0.0  # Вектор "вверх"
    )
```

### Управление мышью

- **Левая кнопка мыши + перемещение**: вращение камеры
- **Колесо мыши**: приближение/отдаление

```python
def handle_mouse_motion(self, x, y):
    if self.mouse_button != glut.GLUT_LEFT_BUTTON:
        return

    # Рассчитываем изменение позиции мыши
    dx = x - self.prev_x
    dy = y - self.prev_y

    # Обновляем углы камеры
    self.theta += dx * 0.5
    self.phi += dy * 0.5

    # Ограничиваем вертикальный угол
    self.phi = max(-85, min(85, self.phi))

    # Запоминаем текущее положение мыши
    self.prev_x = x
    self.prev_y = y
```

## Интерфейс пользователя

### Информационные панели

Информация отображается как наложение 2D текста поверх 3D сцены:

```python
def render_text(text, x, y):
    # Отключение 3D функций
    gl.glDisable(gl.GL_LIGHTING)
    gl.glDisable(gl.GL_DEPTH_TEST)

    # Переключение на 2D проекцию
    gl.glMatrixMode(gl.GL_PROJECTION)
    gl.glPushMatrix()
    gl.glLoadIdentity()
    gl.glOrtho(0, WINDOW_WIDTH, 0, WINDOW_HEIGHT, -1, 1)

    gl.glMatrixMode(gl.GL_MODELVIEW)
    gl.glPushMatrix()
    gl.glLoadIdentity()

    # Отрисовка текста
    gl.glColor3f(1, 1, 1)
    gl.glRasterPos2i(x, y)
    for ch in text:
        glut.glutBitmapCharacter(glut.GLUT_BITMAP_8_BY_13, ord(ch))

    # Восстановление состояния
    gl.glPopMatrix()
    gl.glMatrixMode(gl.GL_PROJECTION)
    gl.glPopMatrix()
    gl.glMatrixMode(gl.GL_MODELVIEW)

    # Включение 3D функций
    gl.glEnable(gl.GL_LIGHTING)
    gl.glEnable(gl.GL_DEPTH_TEST)
```

### Клавиатурное управление

Система поддерживает интерактивное управление с помощью клавиатуры:

- **H**: показать/скрыть справку
- **P**: пауза/продолжение симуляции
- **E**: показать/скрыть эмиттер
- **A**: показать/скрыть аттрактор
- **Пробел**: включить/отключить влияние аттрактора
- **R**: сбросить частицы
- **↑/↓**: увеличить/уменьшить количество частиц
- **←/→**: уменьшить/увеличить длину следа

## Оптимизации

### Управление ресурсами

1. **Ограничение частиц**: пользователь может контролировать количество частиц для баланса между производительностью и качеством
2. **Ограничение длины следа**: более короткие следы требуют меньше памяти и вычислений
3. **Ограничение по времени**: шаг симуляции ограничен для стабильной работы на разном оборудовании

    ```python
    # Ограничение временного шага для стабильной физики
    dt = min(dt, 0.05)
    ```

4. **Отсечение по расстоянию**: аттрактор воздействует только на частицы в пределах своего радиуса действия

    ```python
    if abs(distance) > self.range:
        return np.zeros(3)
    ```
